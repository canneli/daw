<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Canneli DAW Beta</title>
  
  <!-- √çcones -->
  <link rel="icon" id="faviconLink" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cdefs%3E%3ClinearGradient id='bg' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ff0055'/%3E%3Cstop offset='100%25' stop-color='%238800ff'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='512' height='512' rx='120' fill='url(%23bg)'/%3E%3Cpath d='M128 256h0m32-96v192m64-288v384m64-256v128m64-192v256m64-64h0' stroke='%23ffffff' stroke-width='40' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E">
  <link rel="apple-touch-icon" id="appleIconLink" href="">

  <!-- Script √çcone iOS -->
  <script>
    (function() {
      const size = 512;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createLinearGradient(0, 0, size, size);
      grad.addColorStop(0, '#ff0055');
      grad.addColorStop(1, '#8800ff');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 40;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      function line(x, y, h) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + h); ctx.stroke(); }
      line(128, 256, 0.1); line(160, 160, 192); line(224, 64, 384); line(288, 192, 128); line(352, 128, 256); line(416, 320, 0.1);
      const pngUrl = canvas.toDataURL('image/png');
      window.addEventListener('load', () => {
          const appleLink = document.getElementById('appleIconLink');
          const favLink = document.getElementById('faviconLink');
          if(appleLink) appleLink.href = pngUrl;
          if(favLink) favLink.href = pngUrl;
      });
    })();
  </script>

  <!-- PWA Manifest -->
  <link rel="manifest" href='data:application/manifest+json,{"name":"Canneli DAW","short_name":"Canneli","start_url":".","id":"/","display":"standalone","background_color":"#08000a","theme_color":"#ff0055","description":"Est√∫dio de √Åudio Web","orientation":"portrait","icons":[{"src":"data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 512 512%27%3E%3Cdefs%3E%3ClinearGradient id=%27bg%27 x1=%270%25%27 y1=%270%25%27 x2=%27100%25%27 y2=%27100%25%27%3E%3Cstop offset=%270%25%27 stop-color=%27%23ff0055%27/%3E%3Cstop offset=%27100%25%27 stop-color=%27%238800ff%27/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width=%27512%27 height=%27512%27 rx=%27120%27 fill=%27url(%23bg)%27/%3E%3Cpath d=%27M128 256h0m32-96v192m64-288v384m64-256v128m64-192v256m64-64h0%27 stroke=%27%23ffffff%27 stroke-width=%2740%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3C/svg%3E","sizes":"192x192","type":"image/svg+xml","purpose":"any maskable"},{"src":"data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 512 512%27%3E%3Cdefs%3E%3ClinearGradient id=%27bg%27 x1=%270%25%27 y1=%270%25%27 x2=%27100%25%27 y2=%27100%25%27%3E%3Cstop offset=%270%25%27 stop-color=%27%23ff0055%27/%3E%3Cstop offset=%27100%25%27 stop-color=%27%238800ff%27/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width=%27512%27 height=%27512%27 rx=%27120%27 fill=%27url(%23bg)%27/%3E%3Cpath d=%27M128 256h0m32-96v192m64-288v384m64-256v128m64-192v256m64-64h0%27 stroke=%27%23ffffff%27 stroke-width=%2740%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3C/svg%3E","sizes":"512x512","type":"image/svg+xml","purpose":"any maskable"}]}'>

  <!-- Meta iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Fonts & Libs -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700;800;900&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>

  <style>
    :root {
      --primary: #ff0055;
      --secondary: #8800ff;
      --accent: #ffffff;
      --bg-deep: #08000a;
      --glass-panel: rgba(20, 10, 30, 0.7);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text-main: #ffffff;
      --text-muted: #b3b3b3;
      --glow-primary: 0 0 25px rgba(255, 0, 85, 0.5);
    }

    * { box-sizing: border-box; }

    body {
      width: 100vw; height: 100vh;
      font-family: 'Montserrat', system-ui, sans-serif;
      background-color: #000;
      color: var(--text-main);
      margin: 0; padding: 0;
      display: flex; justify-content: center; align-items: center;
      overflow: hidden; position: relative;
    }

    /* Background Animado */
    .bg-anim { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background: radial-gradient(circle at 10% 20%, #2a0000, transparent 40%), radial-gradient(circle at 90% 80%, #1a0033, transparent 40%); }
    .bg-anim::after { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: conic-gradient(from 0deg at 50% 50%, rgba(136,0,255,0.08), transparent, rgba(255,0,85,0.08), transparent); animation: rotateBG 25s linear infinite; opacity: 0.6; }
    @keyframes rotateBG { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* App Shell */
    .app-shell {
      width: 100%; max-width: 600px; height: 100%;
      background-color: var(--bg-deep);
      display: flex; flex-direction: column;
      position: relative;
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
    }
    @media (min-width: 600px) { .app-shell { height: 95vh; border-radius: 20px; border: 1px solid var(--glass-border); } }

    /* Header */
    header {
      padding: 15px 20px; display: flex; justify-content: space-between; align-items: center;
      background: rgba(10, 5, 20, 0.9); backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--glass-border); z-index: 100;
    }
    h3 { margin: 0; font-size: 16px; font-weight: 300; letter-spacing: 1px; text-transform: uppercase; color: #fff; display: flex; align-items: center; gap: 8px; }
    h3 strong { background: linear-gradient(135deg, #fff, var(--primary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900; }
    .badge-pro { font-size: 9px; background: linear-gradient(90deg, var(--primary), var(--secondary)); padding: 2px 6px; border-radius: 4px; font-weight: 800; }

    /* Container Principal */
    .container {
      flex: 1; display: flex; flex-direction: column; 
      padding: 0; overflow: hidden; 
    }

    /* Timeline Area (Design Envelopante) */
    #timelineArea {
      flex: 1; overflow-y: auto; padding: 20px 10px;
      display: flex; flex-direction: column; 
      gap: 0; /* Remove gaps para efeito conectado */
      scroll-behavior: smooth;
    }
    #timelineArea::-webkit-scrollbar { width: 4px; }
    #timelineArea::-webkit-scrollbar-thumb { background: var(--glass-border); }

    /* Faixa de √Åudio (Track) - Design Unificado */
    .track {
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--glass-border);
      border-bottom: none; /* Remove borda inferior para conectar */
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: background 0.2s;
      position: relative;
      border-left: 4px solid rgba(255,255,255,0.1); /* Trilho visual esquerdo */
    }
    .track:first-child { border-top-left-radius: 12px; border-top-right-radius: 12px; }
    .track:last-child { 
        border-bottom-left-radius: 12px; border-bottom-right-radius: 12px; 
        border-bottom: 1px solid var(--glass-border); /* Fecha o bloco */
    }
    
    .track:hover { background: rgba(255,255,255,0.04); }
    .track:hover { border-left-color: var(--primary); } /* Highlight no trilho */

    .track.active-recording { border-left-color: var(--primary); background: rgba(255,0,85,0.05); }

    .track-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 6px 12px; background: rgba(0,0,0,0.2); 
      border-bottom: 1px solid rgba(255,255,255,0.03);
    }
    .track-info { display: flex; align-items: center; gap: 8px; }
    .track-name { font-size: 10px; font-weight: 700; text-transform: uppercase; color: var(--text-muted); letter-spacing: 1px; }
    .track-actions { display: flex; gap: 10px; align-items: center; }
    
    .btn-icon-small { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 12px; transition: 0.2s; padding: 4px; }
    .btn-icon-small:hover { color: #fff; transform: scale(1.1); }
    .btn-icon-small.danger:hover { color: var(--danger); }
    
    .btn-arm { color: #555; }
    .btn-arm.armed { color: var(--primary); text-shadow: 0 0 10px var(--primary); animation: pulseArm 2s infinite; }
    @keyframes pulseArm { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    .track-body { display: flex; align-items: center; padding: 10px; gap: 10px; }
    
    /* Controles da Faixa (Esquerda) */
    .track-controls { display: flex; flex-direction: column; gap: 8px; width: 90px; flex-shrink: 0; }
    
    .track-btn-row { display: flex; gap: 5px; }
    .btn-track-toggle {
      flex: 1; border: 1px solid var(--glass-border); background: transparent; color: var(--text-muted);
      border-radius: 4px; font-size: 9px; cursor: pointer; padding: 4px 0; font-weight: 700; transition: 0.2s;
    }
    .btn-track-toggle.active { background: var(--secondary); color: #fff; border-color: var(--secondary); }
    .btn-track-toggle.mute.active { background: var(--danger); border-color: var(--danger); }

    .vol-slider { width: 100%; height: 3px; -webkit-appearance: none; background: rgba(255,255,255,0.1); outline: none; }
    .vol-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; border-radius: 50%; background: #fff; cursor: pointer; }

    .fx-select {
      width: 100%; background: rgba(0,0,0,0.3); border: 1px solid var(--glass-border); color: var(--text-muted);
      font-size: 9px; border-radius: 4px; padding: 2px; outline: none;
    }

    /* Waveform (Direita) */
    .track-wave { flex: 1; height: 60px; background: rgba(0,0,0,0.2); border-radius: 6px; position: relative; overflow: hidden; cursor: text; }
    .track-wave canvas { width: 100%; height: 100%; display: block; }

    /* Barra de Transporte (Bottom Fixo) */
    #transportBar {
      padding: 10px 20px 20px 20px; background: rgba(10, 5, 20, 0.95); backdrop-filter: blur(20px);
      border-top: 1px solid var(--glass-border);
      display: flex; flex-direction: column; gap: 10px; z-index: 100;
    }

    /* Mixer Master UI */
    .master-mixer-row {
        display: flex; align-items: center; justify-content: space-between; gap: 10px; padding: 0 5px;
    }
    .master-label { font-size: 9px; color: var(--text-muted); font-weight: 700; text-transform: uppercase; letter-spacing: 1px; width: 50px; }
    .master-slider-container { flex: 1; display: flex; align-items: center; gap: 10px; }
    #masterVolSlider { flex: 1; height: 4px; background: #333; border-radius: 2px; -webkit-appearance: none; }
    #masterVolSlider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
    #masterVolDisplay { font-size: 9px; font-family: monospace; color: var(--primary); width: 30px; text-align: right; }

    .transport-controls { display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 5px; }
    
    .btn-circle {
      width: 45px; height: 45px; border-radius: 50%; border: none; cursor: pointer;
      display: flex; align-items: center; justify-content: center; font-size: 18px; color: #fff;
      transition: all 0.2s; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #btnPlayMaster { background: #fff; color: #000; }
    #btnStopMaster { background: rgba(255,255,255,0.1); font-size: 14px; }
    #btnRecordMaster { background: linear-gradient(135deg, #ff0055, #ff0000); box-shadow: 0 0 20px rgba(255,0,85,0.4); width: 55px; height: 55px; font-size: 20px; }
    #btnRecordMaster.recording { animation: pulseRec 1.5s infinite; }
    
    @keyframes pulseRec { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255,0,85,0.7); } 70% { transform: scale(1.1); box-shadow: 0 0 0 15px rgba(255,0,85,0); } 100% { transform: scale(1); } }

    .bottom-actions { display: flex; gap: 10px; margin-top: 5px; }
    .btn-action {
      flex: 1; padding: 12px; border: 1px solid var(--glass-border); border-radius: 8px;
      background: rgba(255,255,255,0.05); color: #fff; font-size: 10px; font-weight: 700;
      text-transform: uppercase; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;
    }
    .btn-action:hover { background: rgba(255,255,255,0.1); }
    #btnAddTrack { border-style: dashed; }
    #btnExport { background: var(--secondary); border: none; }

    /* Visualizer Mini */
    #masterVis { height: 4px; width: 100%; background: #222; border-radius: 2px; overflow: hidden; }
    #masterVisBar { height: 100%; width: 0%; background: linear-gradient(90deg, var(--secondary), var(--primary)); transition: width 0.1s; }

    /* Bot√£o Install */
    #btnInstall {
      position: fixed; bottom: 30px; right: 30px; z-index: 2000;
      background: rgba(20, 10, 30, 0.6); backdrop-filter: blur(12px);
      color: #fff; font-size: 14px; font-weight: 800; text-transform: uppercase; letter-spacing: 2px;
      border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 30px; padding: 16px 32px;
      display: none; align-items: center; gap: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5); transition: all 0.4s;
      opacity: 0;
    }
    #btnInstall.visible { display: flex; opacity: 1; }
    @media (max-width: 600px) {
        #btnInstall {
            padding: 8px 14px; font-size: 9px; bottom: 160px; /* Mais alto */
            right: 10px; border-radius: 15px; background: rgba(0,0,0,0.5); opacity: 0.7; box-shadow: none;
        }
    }
    
    #statusOverlay {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.9); padding: 20px 40px; border-radius: 12px;
        color: #fff; z-index: 5000; display: none; text-align: center;
        border: 1px solid var(--glass-border);
    }
  </style>
</head>
<body>
  <div class="bg-anim"></div>
  
  <main class="app-shell">
    <header>
      <h3><strong>Canneli</strong> DAW <span class="badge-pro">BETA</span></h3>
      <div id="clock">00:00</div>
    </header>

    <!-- Timeline Area: Onde as faixas ficam -->
    <div id="timelineArea">
      <div style="text-align:center; padding: 40px; color: var(--text-muted); opacity: 0.5;">
        <p>Toque em <strong>+</strong> para criar uma faixa<br>ou grave para come√ßar.</p>
      </div>
    </div>

    <!-- Barra de Transporte -->
    <div id="transportBar">
        <!-- Visualizer -->
        <div id="masterVis"><div id="masterVisBar"></div></div>
        
        <!-- Master Mixer -->
        <div class="master-mixer-row">
            <span class="master-label">Master</span>
            <div class="master-slider-container">
                <span style="font-size:10px">üîà</span>
                <input type="range" id="masterVolSlider" min="0" max="1.5" step="0.01" value="1">
                <span id="masterVolDisplay">100%</span>
            </div>
        </div>

        <div class="transport-controls">
            <button id="btnStopMaster" class="btn-circle" title="Parar (Reset)">‚ñ†</button>
            <button id="btnRecordMaster" class="btn-circle" title="Gravar">‚óè</button>
            <button id="btnPlayMaster" class="btn-circle" title="Play">‚ñ∂</button>
        </div>

        <div class="bottom-actions">
            <button id="btnAddTrack" class="btn-action">+ Nova Faixa</button>
            <button id="btnImport" class="btn-action">üìÇ Importar</button>
            <button id="btnExport" class="btn-action">üíæ Exportar Mix</button>
        </div>
        <input type="file" id="fileInput" hidden accept="audio/*">
    </div>
  </main>

  <button id="btnInstall">INSTALAR</button>
  <div id="statusOverlay">Processando...</div>

  <script>
    // --- GERENCIADOR DE ESTADO E AUDIO ---
    const AudioEngine = {
        ctx: null,
        tracks: [], // Array de objetos Track
        isPlaying: false,
        startTime: 0,
        masterGain: null,
        analyser: null,
        recorder: null,
        recordingChunks: [],
        
        async init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 64;
                this.masterGain.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                this.startVisualizer();
            }
            if (this.ctx.state === 'suspended') await this.ctx.resume();
        },

        setMasterVolume(val) {
            if (this.masterGain) this.masterGain.gain.value = val;
        },

        addTrack(buffer = null, name = "Faixa de √Åudio") {
            const trackId = Date.now() + Math.floor(Math.random()*1000);
            const track = {
                id: trackId,
                name: name,
                buffer: buffer, // AudioBuffer
                gainNode: this.ctx.createGain(),
                sourceNode: null,
                volume: 1.0,
                muted: false,
                solo: false,
                effect: 'none',
                armed: false,
                selStart: 0,
                selEnd: 0,
                dom: null
            };
            
            track.dom = UI.createTrackElement(track);
            document.getElementById('timelineArea').appendChild(track.dom);
            
            const emptyMsg = document.querySelector('#timelineArea div[style*="text-align:center"]');
            if(emptyMsg) emptyMsg.style.display = 'none';

            if (buffer) UI.drawWaveform(track);

            this.tracks.push(track);
            return track;
        },

        removeTrack(id) {
            const idx = this.tracks.findIndex(t => t.id === id);
            if (idx > -1) {
                this.tracks[idx].dom.remove();
                this.tracks.splice(idx, 1);
            }
        },

        toggleArm(id) {
            this.tracks.forEach(t => {
                if (t.id === id) t.armed = !t.armed;
                else t.armed = false; 
                
                const btn = t.dom.querySelector('.btn-arm');
                if(t.armed) btn.classList.add('armed');
                else btn.classList.remove('armed');
            });
        },

        cutSelection(id) {
            const track = this.tracks.find(t => t.id === id);
            if (!track || !track.buffer) return;
            if (Math.abs(track.selEnd - track.selStart) < 0.001) return alert("Selecione um trecho na onda para cortar.");

            const rate = track.buffer.sampleRate;
            const channels = track.buffer.numberOfChannels;
            const startFrame = Math.floor(track.selStart * track.buffer.length);
            const endFrame = Math.floor(track.selEnd * track.buffer.length);
            const cutLen = endFrame - startFrame;
            const newLen = track.buffer.length - cutLen;

            if (newLen <= 0) {
                track.buffer = null; 
                UI.drawWaveform(track);
                return;
            }

            const newBuffer = this.ctx.createBuffer(channels, newLen, rate);

            for (let c = 0; c < channels; c++) {
                const oldData = track.buffer.getChannelData(c);
                const newData = newBuffer.getChannelData(c);
                newData.set(oldData.subarray(0, startFrame));
                newData.set(oldData.subarray(endFrame), startFrame);
            }

            track.buffer = newBuffer;
            track.selStart = 0; track.selEnd = 0; 
            UI.drawWaveform(track);
        },

        play() {
            if (this.isPlaying) this.stop();
            this.init();
            
            const now = this.ctx.currentTime;
            this.tracks.forEach(t => {
                if (!t.buffer) return;
                
                const source = this.ctx.createBufferSource();
                source.buffer = t.buffer;
                
                let input = source;
                
                if (t.effect !== 'none') {
                    const fxNode = this.createEffect(t.effect);
                    input.connect(fxNode.in);
                    input = fxNode.out;
                }

                t.gainNode.gain.value = t.muted ? 0 : t.volume;
                input.connect(t.gainNode);
                t.gainNode.connect(this.masterGain);
                
                source.start(now);
                t.sourceNode = source;
            });
            
            this.isPlaying = true;
            UI.setPlayState(true);
        },

        stop() {
            this.tracks.forEach(t => {
                if (t.sourceNode) {
                    try { t.sourceNode.stop(); } catch(e){}
                    t.sourceNode = null;
                }
            });
            this.isPlaying = false;
            UI.setPlayState(false);
        },

        async startRecording() {
            await this.init();
            if (this.isPlaying) this.stop();

            const armedTrack = this.tracks.find(t => t.armed);

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
                this.recordingChunks = [];
                const options = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? { mimeType: 'audio/webm;codecs=opus' } : {};
                this.recorder = new MediaRecorder(stream, options);
                
                this.recorder.ondataavailable = e => this.recordingChunks.push(e.data);
                this.recorder.onstop = async () => {
                    const blob = new Blob(this.recordingChunks, { type: 'audio/webm' });
                    const arrayBuffer = await blob.arrayBuffer();
                    const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                    
                    if (armedTrack) {
                        armedTrack.buffer = audioBuffer;
                        UI.drawWaveform(armedTrack);
                        armedTrack.armed = false; 
                        armedTrack.dom.querySelector('.btn-arm').classList.remove('armed');
                    } else {
                        this.addTrack(audioBuffer, "Grava√ß√£o " + (this.tracks.length + 1));
                    }
                    
                    stream.getTracks().forEach(t => t.stop());
                };
                
                this.recorder.start();
                UI.setRecordingState(true);
            } catch (e) {
                alert("Erro ao acessar microfone: " + e.message);
            }
        },

        stopRecording() {
            if (this.recorder && this.recorder.state !== 'inactive') {
                this.recorder.stop();
                UI.setRecordingState(false);
            }
        },

        async exportMix() {
            if (this.tracks.length === 0) return alert("Nada para exportar!");
            
            UI.showOverlay("Renderizando Mix...");
            
            let maxDuration = 0;
            this.tracks.forEach(t => { if(t.buffer && t.buffer.duration > maxDuration) maxDuration = t.buffer.duration; });
            
            if (maxDuration === 0) { UI.hideOverlay(); return alert("Faixas vazias."); }

            const offlineCtx = new OfflineAudioContext(2, maxDuration * 44100, 44100);
            
            this.tracks.forEach(t => {
                if (!t.buffer || t.muted) return;
                
                const source = offlineCtx.createBufferSource();
                source.buffer = t.buffer;
                
                const gain = offlineCtx.createGain();
                gain.gain.value = t.volume;
                
                let input = source;
                // Recriar efeitos no offline context
                if (t.effect !== 'none') {
                    // Simula√ß√£o simplificada para offline, idealmente replicaria createEffect
                    // Aqui mantemos simples para garantir exporta√ß√£o
                    const d = offlineCtx.createDelay(); 
                    if(t.effect === 'echo') { d.delayTime.value = 0.4; input.connect(d); d.connect(gain); }
                    // Outros efeitos n√£o implementados offline nesta demo para estabilidade
                }

                input.connect(gain);
                gain.connect(offlineCtx.destination);
                source.start(0);
            });

            const renderedBuffer = await offlineCtx.startRendering();
            
            UI.showOverlay("Codificando MP3...");
            setTimeout(() => {
               this.encodeMP3(renderedBuffer); 
            }, 100);
        },

        encodeMP3(buffer) {
            const mp3encoder = new lamejs.Mp3Encoder(1, 44100, 192); 
            const samples = buffer.getChannelData(0); 
            const sampleBlockSize = 1152;
            const mp3Data = [];
            
            const samplesInt16 = new Int16Array(samples.length);
            for (let i = 0; i < samples.length; i++) {
                samplesInt16[i] = samples[i] < 0 ? samples[i] * 0x8000 : samples[i] * 0x7FFF;
            }
            
            for (let i = 0; i < samplesInt16.length; i += sampleBlockSize) {
                const chunk = samplesInt16.subarray(i, i + sampleBlockSize);
                const mp3buf = mp3encoder.encodeBuffer(chunk);
                if (mp3buf.length > 0) mp3Data.push(mp3buf);
            }
            
            const endBuf = mp3encoder.flush();
            if (endBuf.length > 0) mp3Data.push(endBuf);
            
            const blob = new Blob(mp3Data, { type: 'audio/mp3' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `Canneli_Mix_${Date.now()}.mp3`;
            a.click();
            
            UI.hideOverlay();
        },

        createEffect(type) {
            const input = this.ctx.createGain();
            const output = this.ctx.createGain();
            
            if (type === 'echo') {
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.4;
                const feedback = this.ctx.createGain();
                feedback.gain.value = 0.4;
                input.connect(output); 
                input.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(output);
            } else if (type === 'robot') {
                const osc = this.ctx.createOscillator();
                osc.frequency.value = 50;
                osc.start();
                const mod = this.ctx.createGain();
                osc.connect(mod.gain);
                input.connect(mod);
                mod.connect(output);
            } else if (type === 'radio') {
                const filter = this.ctx.createBiquadFilter();
                filter.type = "bandpass";
                filter.frequency.value = 1000;
                input.connect(filter);
                filter.connect(output);
            } else if (type === 'studio') {
                // Studio: EQ + Reverb (Convolver)
                const eq = this.ctx.createBiquadFilter(); 
                eq.type='highshelf'; eq.frequency.value=3000; eq.gain.value=5;
                
                const conv = this.ctx.createConvolver();
                // Gerar impulso para reverb
                const len = this.ctx.sampleRate * 2; 
                const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for(let i=0;i<2;i++) {
                    const ch = buf.getChannelData(i);
                    for(let j=0;j<len;j++) ch[j] = (Math.random()*2-1)*Math.pow(1-j/len,2);
                }
                conv.buffer = buf;
                
                const wet = this.ctx.createGain(); wet.gain.value = 0.4;
                const dry = this.ctx.createGain(); dry.gain.value = 0.8;
                
                input.connect(eq);
                eq.connect(dry); dry.connect(output); // Dry Path
                eq.connect(conv); conv.connect(wet); wet.connect(output); // Wet Path
                
            } else if (type === 'magic') {
                // Magic: Compressor + EQ + Delay
                const comp = this.ctx.createDynamicsCompressor();
                comp.threshold.value = -20; comp.ratio.value = 4;
                
                const eq = this.ctx.createBiquadFilter();
                eq.type = 'highshelf'; eq.frequency.value = 8000; eq.gain.value = 4;
                
                const delay = this.ctx.createDelay(); delay.delayTime.value = 0.15;
                const delayGain = this.ctx.createGain(); delayGain.gain.value = 0.2;
                
                input.connect(comp);
                comp.connect(eq);
                eq.connect(output); // Main signal
                eq.connect(delay); delay.connect(delayGain); delayGain.connect(output); // Sparkle
                
            } else {
                input.connect(output);
            }
            return { in: input, out: output };
        },

        startVisualizer() {
            const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
            const bar = document.getElementById('masterVisBar');
            const draw = () => {
                requestAnimationFrame(draw);
                this.analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
                const avg = sum / dataArray.length;
                bar.style.width = Math.min(100, avg * 1.5) + '%';
            };
            draw();
        }
    };

    // --- UI MANAGER ---
    const UI = {
        createTrackElement(track) {
            const div = document.createElement('div');
            div.className = 'track';
            div.id = `track_${track.id}`;
            div.innerHTML = `
                <div class="track-header">
                    <div class="track-info">
                        <span class="track-name" contenteditable="true">${track.name}</span>
                    </div>
                    <div class="track-actions">
                        <button class="btn-icon-small btn-arm" title="Armar para Grava√ß√£o" onclick="AudioEngine.toggleArm(${track.id})">‚óè</button>
                        <button class="btn-icon-small" title="Cortar Sele√ß√£o" onclick="AudioEngine.cutSelection(${track.id})">‚úÇÔ∏è</button>
                        <button class="btn-icon-small danger" onclick="AudioEngine.removeTrack(${track.id})">‚úï</button>
                    </div>
                </div>
                <div class="track-body">
                    <div class="track-controls">
                        <div class="track-btn-row">
                            <button class="btn-track-toggle mute" onclick="UI.toggleMute(${track.id}, this)">M</button>
                            <button class="btn-track-toggle" onclick="UI.toggleSolo(${track.id}, this)">S</button>
                        </div>
                        <input type="range" class="vol-slider" min="0" max="1.5" step="0.1" value="1" 
                               oninput="UI.updateVol(${track.id}, this.value)">
                        <select class="fx-select" onchange="UI.updateFx(${track.id}, this.value)">
                            <option value="none">S/ Efeito</option>
                            <option value="studio">Studio</option>
                            <option value="magic">‚ú® Magic</option>
                            <option value="echo">Eco</option>
                            <option value="robot">Rob√¥</option>
                            <option value="radio">R√°dio</option>
                        </select>
                    </div>
                    <div class="track-wave">
                        <canvas id="cv_${track.id}" width="400" height="60"></canvas>
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const cv = div.querySelector('canvas');
                let isSelecting = false;
                let startX = 0;

                const getX = (e) => {
                    const rect = cv.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    return Math.max(0, Math.min(clientX - rect.left, rect.width)) / rect.width;
                };

                const startSel = (e) => {
                    isSelecting = true;
                    startX = getX(e);
                    track.selStart = startX;
                    track.selEnd = startX;
                    UI.drawWaveform(track);
                };

                const moveSel = (e) => {
                    if(!isSelecting) return;
                    e.preventDefault(); 
                    const curX = getX(e);
                    track.selStart = Math.min(startX, curX);
                    track.selEnd = Math.max(startX, curX);
                    UI.drawWaveform(track);
                };

                const endSel = () => { isSelecting = false; };

                cv.addEventListener('mousedown', startSel);
                window.addEventListener('mousemove', moveSel);
                window.addEventListener('mouseup', endSel);
                
                cv.addEventListener('touchstart', startSel, {passive: false});
                window.addEventListener('touchmove', moveSel, {passive: false});
                window.addEventListener('touchend', endSel);
            }, 0);

            return div;
        },

        toggleMute(id, btn) {
            const t = AudioEngine.tracks.find(x => x.id === id);
            if(t) {
                t.muted = !t.muted;
                btn.classList.toggle('active');
                if(t.gainNode) t.gainNode.gain.value = t.muted ? 0 : t.volume;
            }
        },
        toggleSolo(id, btn) {
            btn.classList.toggle('active');
        },
        updateVol(id, val) {
            const t = AudioEngine.tracks.find(x => x.id === id);
            if(t) {
                t.volume = parseFloat(val);
                if(t.gainNode && !t.muted) t.gainNode.gain.value = t.volume;
            }
        },
        updateFx(id, val) {
            const t = AudioEngine.tracks.find(x => x.id === id);
            if(t) t.effect = val;
        },

        drawWaveform(track) {
            requestAnimationFrame(() => {
                const cv = document.getElementById(`cv_${track.id}`);
                if(!cv || !track.buffer) return;
                const ctx = cv.getContext('2d');
                const w = cv.width; const h = cv.height;
                const data = track.buffer.getChannelData(0);
                const step = Math.ceil(data.length / w);
                const amp = h / 2;
                
                ctx.clearRect(0,0,w,h);
                
                ctx.fillStyle = "#ff0055"; 
                ctx.beginPath();
                for(let i=0; i < w; i++){
                    let min = 1.0; let max = -1.0;
                    for (let j=0; j<step; j++) {
                        const datum = data[(i*step)+j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    ctx.fillRect(i, (1+min)*amp, 1, Math.max(1, (max-min)*amp));
                }

                if (track.selEnd > track.selStart) {
                    const sX = track.selStart * w;
                    const eX = track.selEnd * w;
                    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.fillRect(sX, 0, eX - sX, h);
                    ctx.strokeStyle = "#fff";
                    ctx.beginPath();
                    ctx.moveTo(sX,0); ctx.lineTo(sX,h);
                    ctx.moveTo(eX,0); ctx.lineTo(eX,h);
                    ctx.stroke();
                }
            });
        },

        setPlayState(playing) {
            document.getElementById('btnPlayMaster').innerText = playing ? '‚ùö‚ùö' : '‚ñ∂';
        },
        
        setRecordingState(recording) {
            const btn = document.getElementById('btnRecordMaster');
            if(recording) {
                btn.classList.add('recording');
            } else {
                btn.classList.remove('recording');
            }
        },
        
        showOverlay(msg) {
            const el = document.getElementById('statusOverlay');
            el.innerText = msg;
            el.style.display = 'block';
        },
        hideOverlay() {
            document.getElementById('statusOverlay').style.display = 'none';
        }
    };

    // --- BINDINGS ---
    document.getElementById('btnAddTrack').onclick = () => AudioEngine.addTrack(null, "Nova Faixa");
    
    document.getElementById('btnImport').onclick = () => document.getElementById('fileInput').click();
    
    document.getElementById('fileInput').onchange = async (e) => {
        const file = e.target.files[0];
        if(!file) return;
        await AudioEngine.init();
        UI.showOverlay("Carregando...");
        const buf = await file.arrayBuffer();
        const audioBuf = await AudioEngine.ctx.decodeAudioData(buf);
        AudioEngine.addTrack(audioBuf, file.name);
        UI.hideOverlay();
        e.target.value = '';
    };

    document.getElementById('btnPlayMaster').onclick = () => {
        if(AudioEngine.isPlaying) AudioEngine.stop();
        else AudioEngine.play();
    };
    
    document.getElementById('btnStopMaster').onclick = () => AudioEngine.stop();
    
    document.getElementById('btnRecordMaster').onclick = () => {
        if(AudioEngine.recorder && AudioEngine.recorder.state === 'recording') {
            AudioEngine.stopRecording();
        } else {
            AudioEngine.startRecording();
        }
    };
    
    document.getElementById('btnExport').onclick = () => AudioEngine.exportMix();

    // Master Vol Binding
    document.getElementById('masterVolSlider').oninput = (e) => {
        const val = parseFloat(e.target.value);
        AudioEngine.setMasterVolume(val);
        document.getElementById('masterVolDisplay').innerText = Math.round(val*100) + '%';
    };

    // --- INSTALL BUTTON LOGIC ---
    let deferredPrompt;
    const installBtn = document.getElementById('btnInstall');

    function showInstallButton() {
        const hasSeenInstall = localStorage.getItem('hasSeenInstallPrompt');
        if (!hasSeenInstall) {
            installBtn.classList.add('visible');
            localStorage.setItem('hasSeenInstallPrompt', 'true');
            setTimeout(() => {
                installBtn.style.opacity = '0';
                setTimeout(() => { installBtn.style.display = 'none'; installBtn.classList.remove('visible'); }, 500);
            }, 15000);
        }
    }

    window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        showInstallButton();
    });

    setTimeout(() => {
        if (!deferredPrompt && !localStorage.getItem('hasSeenInstallPrompt')) showInstallButton();
    }, 1000);

    installBtn.addEventListener('click', async () => {
        if (!deferredPrompt) {
            alert("Instala√ß√£o Manual:\n\nüíª PC/Chrome: Menu > 'Transmitir, salvar ou compartilhar' > 'Instalar Canneli DAW'.\nüì± Mobile: Menu > 'Adicionar ao ecr√£ principal'.");
            return;
        }
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        deferredPrompt = null;
        installBtn.style.display = 'none';
    });

    if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
        const swCode = `self.addEventListener('install',e=>self.skipWaiting());self.addEventListener('activate',e=>e.waitUntil(self.clients.claim()));self.addEventListener('fetch',e=>e.respondWith(fetch(e.request)));`;
        const blob = new Blob([swCode], {type: 'application/javascript'});
        navigator.serviceWorker.register(URL.createObjectURL(blob)).catch(console.log);
    }
  </script>
</body>
</html>
