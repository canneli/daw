<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Canneli DAW Pro - Effects Edition</title>
  
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Cdefs%3E%3ClinearGradient id='bg' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23ff0055'/%3E%3Cstop offset='100%25' stop-color='%238800ff'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='512' height='512' rx='120' fill='url(%23bg)'/%3E%3Cpath d='M128 256h0m32-96v192m64-288v384m64-256v128m64-192v256m64-64h0' stroke='%23ffffff' stroke-width='40' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>

  <style>
    :root {
      --primary: #ff0055;
      --secondary: #8800ff;
      --bg-deep: #08000a;
      --glass: rgba(255, 255, 255, 0.05);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text-main: #ffffff;
      --text-muted: #b3b3b3;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      width: 100vw; height: 100vh;
      font-family: 'Montserrat', sans-serif;
      background-color: #000;
      color: var(--text-main);
      margin: 0; overflow: hidden;
      display: flex; justify-content: center; align-items: center;
    }

    .bg-anim { 
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; 
      background: radial-gradient(circle at 20% 30%, #2a0000, transparent 50%), 
                  radial-gradient(circle at 80% 70%, #1a0033, transparent 50%); 
    }

    .app-shell {
      width: 100%; max-width: 800px; height: 100%;
      background-color: var(--bg-deep);
      display: flex; flex-direction: column;
      position: relative;
    }
    @media (min-width: 800px) { .app-shell { height: 95vh; border-radius: 24px; border: 1px solid var(--glass-border); } }

    header {
      padding: 20px; display: flex; justify-content: space-between; align-items: center;
      background: rgba(10, 5, 20, 0.8); backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--glass-border);
    }
    h3 { margin: 0; font-size: 14px; letter-spacing: 2px; text-transform: uppercase; font-weight: 300; }
    h3 strong { font-weight: 900; color: var(--primary); }

    #timelineArea {
      flex: 1; overflow-y: auto; padding: 20px;
      display: flex; flex-direction: column; gap: 15px;
    }

    /* Track Styles */
    .track {
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    .track-header {
      padding: 10px 15px; background: rgba(255,255,255,0.03);
      display: flex; justify-content: space-between; align-items: center;
    }
    .track-name { font-weight: 700; font-size: 11px; text-transform: uppercase; color: var(--text-muted); }

    .track-body { display: flex; padding: 15px; gap: 15px; }
    
    .track-controls { width: 120px; display: flex; flex-direction: column; gap: 10px; }
    
    .fx-select {
      width: 100%; background: #111; border: 1px solid var(--glass-border);
      color: #fff; font-size: 10px; padding: 6px; border-radius: 6px;
      font-weight: 600; cursor: pointer;
    }

    .fx-params-panel {
      margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3);
      border-radius: 8px; display: none; flex-direction: column; gap: 8px;
    }
    .fx-params-panel.active { display: flex; }
    .param-row { display: flex; flex-direction: column; gap: 2px; }
    .param-row label { font-size: 8px; color: var(--text-muted); text-transform: uppercase; }
    .param-slider { width: 100%; height: 2px; -webkit-appearance: none; background: #333; outline: none; }
    .param-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; background: var(--primary); border-radius: 50%; cursor: pointer; }

    .track-wave { 
      flex: 1; height: 80px; background: rgba(0,0,0,0.4); 
      border-radius: 10px; position: relative; overflow: hidden; 
    }
    .track-wave canvas { width: 100%; height: 100%; }
    .selection-overlay { position: absolute; top: 0; background: rgba(255,255,255,0.2); height: 100%; pointer-events: none; }
    .playback-cursor { position: absolute; top: 0; width: 2px; height: 100%; background: #fff; box-shadow: 0 0 10px #fff; pointer-events: none; display: none; }

    /* Transport Bar */
    #transportBar {
      padding: 20px; background: rgba(10, 5, 20, 0.95);
      border-top: 1px solid var(--glass-border);
      display: flex; flex-direction: column; gap: 15px;
    }

    .controls-main { display: flex; justify-content: center; align-items: center; gap: 20px; }
    .btn-main {
      width: 50px; height: 50px; border-radius: 50%; border: none; cursor: pointer;
      display: flex; align-items: center; justify-content: center; font-size: 20px;
      transition: transform 0.2s;
    }
    .btn-play { background: #fff; color: #000; }
    .btn-rec { background: var(--primary); color: #fff; }
    .btn-rec.recording { animation: pulse 1.5s infinite; }
    
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(255, 0, 85, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); } }

    .bottom-actions { display: flex; gap: 10px; }
    .btn-sec {
      flex: 1; padding: 12px; background: var(--glass); border: 1px solid var(--glass-border);
      color: #fff; border-radius: 10px; font-size: 10px; font-weight: 700; cursor: pointer;
      text-transform: uppercase;
    }
    .btn-sec:hover { background: rgba(255,255,255,0.1); }

    #statusOverlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.8);
      display: none; flex-direction: column; justify-content: center; align-items: center;
      z-index: 1000; font-weight: 700; gap: 10px;
    }
    .loader { width: 30px; height: 30px; border: 3px solid var(--primary); border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div class="bg-anim"></div>

  <main class="app-shell">
    <header>
      <h3><strong>Canneli</strong> DAW <span style="font-size: 10px; opacity: 0.5;">PRO v2.0</span></h3>
      <div id="timer">00:00:00</div>
    </header>

    <div id="timelineArea">
      <!-- Tracks go here -->
    </div>

    <div id="transportBar">
      <div class="controls-main">
        <button id="btnStop" class="btn-main" style="background: #333; color: #fff; font-size: 14px;">‚ñ†</button>
        <button id="btnRecord" class="btn-main btn-rec">‚óè</button>
        <button id="btnPlay" class="btn-main btn-play">‚ñ∂</button>
      </div>

      <div class="bottom-actions">
        <button id="btnAddTrack" class="btn-sec">+ Faixa</button>
        <button id="btnImport" class="btn-sec">üìÇ Importar</button>
        <button id="btnExport" class="btn-sec" style="background: var(--secondary); border: none;">üíæ Exportar Mix</button>
      </div>
    </div>
  </main>

  <div id="statusOverlay">
    <div class="loader"></div>
    <span id="statusMsg">Processando...</span>
  </div>

  <input type="file" id="fileInput" hidden accept="audio/*">

  <script>
    // --- AUDIO ENGINE ---
    const AudioEngine = {
      ctx: null,
      tracks: [],
      isPlaying: false,
      startTime: 0,
      masterGain: null,
      maxDuration: 10,

      async init() {
        if (!this.ctx) {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.ctx.createGain();
          this.masterGain.connect(this.ctx.destination);
        }
        if (this.ctx.state === 'suspended') await this.ctx.resume();
      },

      addTrack(buffer = null, name = "Nova Faixa") {
        const id = Date.now() + Math.random();
        const track = {
          id, name, buffer,
          volume: 1.0,
          pan: 0,
          muted: false,
          activeEffect: 'none',
          fxParams: {
            compressor: { threshold: -24, ratio: 12 },
            distortion: { amount: 400 },
            delay: { time: 0.3, feedback: 0.4 },
            reverb: { wet: 0.3 }
          },
          nodes: { gain: null, panner: null, fx: null },
          selection: { start: 0, end: 0 }
        };

        this.tracks.push(track);
        UI.renderTrack(track);
        this.updateMaxDuration();
        return track;
      },

      updateMaxDuration() {
        let max = 5;
        this.tracks.forEach(t => { if(t.buffer && t.buffer.duration > max) max = t.buffer.duration; });
        this.maxDuration = max;
      },

      // --- EFEITOS DE TEMPO REAL ---
      createEffectNode(track) {
        const type = track.activeEffect;
        if (type === 'none') return null;

        const input = this.ctx.createGain();
        const output = this.ctx.createGain();

        if (type === 'compressor') {
          const comp = this.ctx.createDynamicsCompressor();
          comp.threshold.value = track.fxParams.compressor.threshold;
          comp.ratio.value = track.fxParams.compressor.ratio;
          input.connect(comp); comp.connect(output);
        } 
        else if (type === 'distortion') {
          const dist = this.ctx.createWaveShaper();
          dist.curve = this.makeDistortionCurve(track.fxParams.distortion.amount);
          input.connect(dist); dist.connect(output);
        }
        else if (type === 'delay') {
          const delay = this.ctx.createDelay();
          delay.delayTime.value = track.fxParams.delay.time;
          const fb = this.ctx.createGain();
          fb.gain.value = track.fxParams.delay.feedback;
          input.connect(output);
          input.connect(delay);
          delay.connect(fb);
          fb.connect(delay);
          delay.connect(output);
        }

        return { in: input, out: output };
      },

      makeDistortionCurve(amount) {
        const k = amount, n = 44100, curve = new Float32Array(n);
        for (let i = 0; i < n; ++i) {
          const x = i * 2 / n - 1;
          curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
        }
        return curve;
      },

      // --- EFEITOS DESTRUTIVOS (BUFFER) ---
      async applyBufferEffect(trackId, type) {
        const track = this.tracks.find(t => t.id === trackId);
        if (!track || !track.buffer) return;

        UI.showStatus("A processar...");
        const buffer = track.buffer;
        
        // Simula√ß√£o de processamento para UI n√£o travar
        await new Promise(r => setTimeout(r, 100));

        for (let c = 0; c < buffer.numberOfChannels; c++) {
          const data = buffer.getChannelData(c);
          
          if (type === 'invert') {
            for (let i = 0; i < data.length; i++) data[i] *= -1;
          }
          if (type === 'normalize') {
            let max = 0;
            for (let i = 0; i < data.length; i++) if (Math.abs(data[i]) > max) max = Math.abs(data[i]);
            if (max > 0) {
              const mult = 1 / max;
              for (let i = 0; i < data.length; i++) data[i] *= mult;
            }
          }
        }

        UI.drawWaveform(track);
        UI.hideStatus();
      },

      play() {
        this.init();
        if (this.isPlaying) this.stop();

        this.startTime = this.ctx.currentTime;
        this.tracks.forEach(t => {
          if (!t.buffer) return;
          const source = this.ctx.createBufferSource();
          source.buffer = t.buffer;

          const gain = this.ctx.createGain();
          gain.gain.value = t.muted ? 0 : t.volume;
          
          const panner = this.ctx.createStereoPanner();
          panner.pan.value = t.pan;

          let chainInput = source;
          const fx = this.createEffectNode(t);

          if (fx) {
            chainInput.connect(fx.in);
            fx.out.connect(panner);
          } else {
            chainInput.connect(panner);
          }

          panner.connect(gain);
          gain.connect(this.masterGain);

          source.start(0);
          t.sourceNode = source;
        });

        this.isPlaying = true;
        UI.updateTransportUI();
      },

      stop() {
        this.tracks.forEach(t => { if(t.sourceNode) { t.sourceNode.stop(); t.sourceNode = null; } });
        this.isPlaying = false;
        UI.updateTransportUI();
      }
    };

    // --- UI MANAGER ---
    const UI = {
      renderTrack(track) {
        const div = document.createElement('div');
        div.className = 'track';
        div.id = `track-${track.id}`;
        div.innerHTML = `
          <div class="track-header">
            <span class="track-name">${track.name}</span>
            <button onclick="AudioEngine.tracks = AudioEngine.tracks.filter(t=>t.id!==${track.id}); this.closest('.track').remove()" style="background:none; border:none; color:red; cursor:pointer">‚úï</button>
          </div>
          <div class="track-body">
            <div class="track-controls">
              <select class="fx-select" onchange="UI.handleFxChange(${track.id}, this.value)">
                <option value="none">Sem Efeito</option>
                <optgroup label="Real-time">
                  <option value="compressor">Compressor</option>
                  <option value="distortion">Distor√ß√£o</option>
                  <option value="delay">Echo / Delay</option>
                </optgroup>
                <optgroup label="Processar Ficheiro">
                  <option value="invert">Inverter Fase</option>
                  <option value="normalize">Normalizar</option>
                </optgroup>
              </select>

              <div class="fx-params-panel" id="params-${track.id}"></div>

              <div style="display:flex; gap:5px; margin-top:5px">
                <button class="btn-sec" style="padding:4px" onclick="UI.toggleMute(${track.id}, this)">MUTE</button>
                <input type="range" min="0" max="1.5" step="0.1" value="1" oninput="UI.updateVol(${track.id}, this.value)" style="flex:1">
              </div>
            </div>
            <div class="track-wave" onmousedown="UI.startSelection(event, ${track.id})">
              <canvas id="canvas-${track.id}"></canvas>
              <div class="selection-overlay" id="select-${track.id}"></div>
              <div class="playback-cursor" id="cursor-${track.id}"></div>
            </div>
          </div>
        `;
        document.getElementById('timelineArea').appendChild(div);
        this.drawWaveform(track);
      },

      handleFxChange(id, val) {
        const track = AudioEngine.tracks.find(t => t.id === id);
        if (['invert', 'normalize'].includes(val)) {
          AudioEngine.applyBufferEffect(id, val);
          return;
        }
        track.activeEffect = val;
        this.renderParams(track);
      },

      renderParams(track) {
        const panel = document.getElementById(`params-${track.id}`);
        panel.innerHTML = '';
        panel.classList.remove('active');

        if (track.activeEffect === 'compressor') {
          panel.classList.add('active');
          panel.innerHTML = `
            <div class="param-row"><label>Threshold</label><input type="range" class="param-slider" min="-60" max="0" value="${track.fxParams.compressor.threshold}" oninput="UI.updateParam(${track.id}, 'compressor', 'threshold', this.value)"></div>
            <div class="param-row"><label>Ratio</label><input type="range" class="param-slider" min="1" max="20" value="${track.fxParams.compressor.ratio}" oninput="UI.updateParam(${track.id}, 'compressor', 'ratio', this.value)"></div>
          `;
        } else if (track.activeEffect === 'distortion') {
          panel.classList.add('active');
          panel.innerHTML = `<div class="param-row"><label>Drive</label><input type="range" class="param-slider" min="0" max="1000" value="${track.fxParams.distortion.amount}" oninput="UI.updateParam(${track.id}, 'distortion', 'amount', this.value)"></div>`;
        } else if (track.activeEffect === 'delay') {
          panel.classList.add('active');
          panel.innerHTML = `
            <div class="param-row"><label>Tempo</label><input type="range" class="param-slider" min="0" max="1" step="0.01" value="${track.fxParams.delay.time}" oninput="UI.updateParam(${track.id}, 'delay', 'time', this.value)"></div>
            <div class="param-row"><label>Feedback</label><input type="range" class="param-slider" min="0" max="0.9" step="0.01" value="${track.fxParams.delay.feedback}" oninput="UI.updateParam(${track.id}, 'delay', 'feedback', this.value)"></div>
          `;
        }
      },

      updateParam(id, fx, param, val) {
        const track = AudioEngine.tracks.find(t => t.id === id);
        track.fxParams[fx][param] = parseFloat(val);
      },

      drawWaveform(track) {
        const canvas = document.getElementById(`canvas-${track.id}`);
        if (!canvas || !track.buffer) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width = canvas.offsetWidth * 2;
        const h = canvas.height = canvas.offsetHeight * 2;
        const data = track.buffer.getChannelData(0);
        const step = Math.ceil(data.length / w);
        const amp = h / 2;

        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#ff0055';
        for (let i = 0; i < w; i++) {
          let min = 1, max = -1;
          for (let j = 0; j < step; j++) {
            const dat = data[(i * step) + j];
            if (dat < min) min = dat;
            if (dat > max) max = dat;
          }
          ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
        }
      },

      updateTransportUI() {
        document.getElementById('btnPlay').innerText = AudioEngine.isPlaying ? '‚ùö‚ùö' : '‚ñ∂';
      },

      showStatus(msg) {
        document.getElementById('statusMsg').innerText = msg;
        document.getElementById('statusOverlay').style.display = 'flex';
      },
      hideStatus() { document.getElementById('statusOverlay').style.display = 'none'; },

      updateVol(id, val) { AudioEngine.tracks.find(t=>t.id===id).volume = parseFloat(val); },
      toggleMute(id, btn) {
        const t = AudioEngine.tracks.find(t=>t.id===id);
        t.muted = !t.muted;
        btn.style.background = t.muted ? 'var(--primary)' : 'var(--glass)';
      }
    };

    // --- EVENTS ---
    document.getElementById('btnAddTrack').onclick = () => AudioEngine.addTrack();
    document.getElementById('btnPlay').onclick = () => AudioEngine.isPlaying ? AudioEngine.stop() : AudioEngine.play();
    document.getElementById('btnStop').onclick = () => AudioEngine.stop();
    document.getElementById('btnImport').onclick = () => document.getElementById('fileInput').click();

    document.getElementById('fileInput').onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      await AudioEngine.init();
      UI.showStatus("A carregar √°udio...");
      try {
        const arr = await file.arrayBuffer();
        const buf = await AudioEngine.ctx.decodeAudioData(arr);
        AudioEngine.addTrack(buf, file.name);
      } catch(err) { alert("Erro ao ler ficheiro."); }
      UI.hideStatus();
    };

    // Anima√ß√£o de Tempo
    setInterval(() => {
      if (AudioEngine.isPlaying) {
        const now = AudioEngine.ctx.currentTime - AudioEngine.startTime;
        const m = Math.floor(now / 60).toString().padStart(2, '0');
        const s = Math.floor(now % 60).toString().padStart(2, '0');
        const ms = Math.floor((now % 1) * 100).toString().padStart(2, '0');
        document.getElementById('timer').innerText = `${m}:${s}:${ms}`;
      }
    }, 50);

  </script>
</body>
</html>
